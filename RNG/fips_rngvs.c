/*
 * Crude test driver for processing the VST and MCT testvector files
 * generated by the CMVP RNGVS product.
 *
 * Note the input files are assumed to have a _very_ specific format
 * as described in the NIST document "The Random Number Generator
 * Validation System (RNGVS)", May 25, 2004.
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <gnutls/gnutls.h>
#include <gnutls/crypto.h>
#include <string.h>
#include "drbg-aes.h" /* the DRBG API isn't exported in gnutls */
#include <ctype.h>

#include "fips_utl.h"

#define mystrcmp(s1, cs2) strncmp(s1, cs2, sizeof(cs2)-1)

static void test(void)
{
	unsigned char *additional[2] = {NULL, NULL};
	unsigned char *entropy = NULL;
	unsigned char *pstring = NULL;
	unsigned char *entropy_reseed = NULL;
	unsigned char *additional_reseed = NULL, *gen = NULL;
	int ret;
	char buf[1024];
	char lbuf[1024];
	struct drbg_aes_ctx ctx;
	char *keyword, *value;
	long i, keylen;
	int j;
	unsigned a_idx = 0;
	long entropy_size, pstring_size;
	long additional_reseed_size;
	long entropy_reseed_size;
	long additional_size[2];
	unsigned complete = 0, gen_len = 0;

	keylen = 0;

	while (fgets(buf, sizeof buf, stdin) != NULL) {
		fputs(buf, stdout);
		if (!mystrcmp(buf, "[AES-256 no df]")) {
			keylen = 32;
		}
		if (!mystrcmp(buf, "[ReturnedBitsLen = ")) {
			gen_len = atoi(buf + sizeof("[ReturnedBitsLen = ")-1);
			gen_len /= 8;
		}

		if (!parse_line(&keyword, &value, lbuf, buf))
			continue;

		if (!strcmp(keyword, "EntropyInput")) {
			entropy = hex2bin_m(value, &entropy_size);
			if (entropy_size != DRBG_AES_SEED_SIZE) {
				fprintf(stderr, "Invalid EntropyInput length %d\n", entropy_size);
				exit(1);
			}
		} else if (!strcmp(keyword, "COUNT")) {
			entropy_size = pstring_size = 0;
			additional_reseed_size = entropy_reseed_size = 0;
			additional_size[0] = additional_size[1] = 0;
		} else if (!strcmp(keyword, "EntropyInputReseed")) {
			entropy_reseed = hex2bin_m(value, &entropy_reseed_size);
			if (entropy_reseed_size != DRBG_AES_SEED_SIZE) {
				fprintf(stderr, "Invalid EntropyInput length %d\n", entropy_size);
				exit(1);
			}
		} else if (!strcmp(keyword, "PersonalizationString")) {
			pstring = hex2bin_m(value, &pstring_size);
			if (pstring_size > DRBG_AES_SEED_SIZE) {
				fprintf(stderr, "Invalid PersonalizationString length %d\n", entropy_size);
				exit(1);
			}
		} else if (!strcmp(keyword, "PredictionResistance")) {
			if (mystrcmp(value, "False") != 0) {
				fprintf(stderr, "Predication resistance isn't supported (%s)\n", value);
				exit(1);
			}
		} else if (!strcmp(keyword, "AdditionalInput")) {
			additional[a_idx] = hex2bin_m(value, &additional_size[a_idx]);
			if (additional_size[a_idx] != DRBG_AES_SEED_SIZE && additional_size[a_idx] != 0) {
				fprintf(stderr, "Invalid AdditionalInput length %d\n", additional_size[a_idx]);
				exit(1);
			}

			a_idx++;
			a_idx %= 2;
			if (a_idx == 0)
				complete = 1;
		} else if (!strcmp(keyword, "AdditionalInputReseed")) {
			additional_reseed = hex2bin_m(value, &additional_reseed_size);
			if (additional_reseed_size != DRBG_AES_SEED_SIZE && additional_reseed_size != 0) {
				fprintf(stderr, "Invalid AdditionalInputReseed length %d\n", additional_reseed_size);
				exit(1);
			}
		}
		
		if (complete == 1) {
			a_idx = 0;
			complete = 0;

			if (!entropy) {
				fprintf(stderr, "Missing entropy or EntropyInputPR\n");
				exit(1);
			}

			ret = drbg_aes_init(&ctx, entropy_size, entropy,
					pstring_size, pstring);
			if (ret == 0) {
				do_print_errors();
				exit(1);
			}
			/* disable the continuous random number generator test */
			ctx.prev_block_present = 1;

			if (entropy_reseed_size > 0) {
				ret = drbg_aes_reseed(&ctx, entropy_reseed_size, entropy_reseed, 
					additional_reseed_size, additional_reseed);
				if (ret == 0) {
					fprintf(stderr, "error setting entropy (%d) and additional (%d)\n", entropy_reseed_size, additional_reseed_size);
					do_print_errors();
					exit(1);
				}
			}

			gen = malloc(gen_len);
			if (gen == NULL) {
				do_print_errors();
				exit(1);
			}

			ret = drbg_aes_generate(&ctx, gen_len, gen, additional_size[0], additional[0]);
			if (ret == 0) {
				do_print_errors();
				exit(1);
			}

			ret = drbg_aes_generate(&ctx, gen_len, gen, additional_size[1], additional[1]);
			if (ret == 0) {
				do_print_errors();
				exit(1);
			}

			pv("ReturnedBits", gen, gen_len);
			free(gen);
			gen = NULL;

			free(additional[0]);
			free(additional[1]);
			additional[0] = additional[1] = NULL;
			
			free(pstring);
			pstring = NULL;
			
			free(entropy);
			entropy = NULL;
		}
	}
}

int main(int argc, char **argv)
{
	if (argc != 1) {
		fprintf(stderr, "%s <infile >outfile\n", argv[0]);
		exit(1);
	}

#ifdef REQUIRE_FIPS
	if (!gnutls_fips140_mode_enabled()) {
		do_print_errors();
		EXIT(1);
	}
#endif

	test();

	return 0;
}
